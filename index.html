<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="resources/my.css" />
<link rel="stylesheet" href="resources/reveal/css/reveal.css" />
<link rel="stylesheet" href="resources/reveal/css/theme/black.css" />
<link rel="stylesheet" href="resources/reveal/lib/css/zenburn.css" />
<link rel="stylesheet" href="resources/my.css" /></head>
<body style="background-repeat: no-repeat; background-size: 15%; background-origin: padding-box; background-position: bottom 1% right 1%; background-image: url('resources/pic/alacris_small_logo.png'); "><div class="reveal"><div class="slides"><section><table><tr><td width="10%"></td><td width="32%"><img src="resources/pic/alacris_logo.png" style="border: 0; vertical-align: top; background-color: transparent" /></td><td width="15%"></td><td><font fgcolor="#ff0000" size="7"><b>ğ”¹â€¯â€¯uilding <br />
ğ”»â€¯â€¯istributed <br />
ğ”¸â€¯â€¯pplications in <br />
ğ•†â€¯â€¯Caml</b></font></td></tr></table>â€¯<div align="left"><small>â€¯</small></div><div align="center" style="font-size: 1.2em; font-weight: bold;">Making types your friends, not your enemies</div>â€¯<p>FranÃ§ois-RenÃ© Rideau, â€¯<em>Alacris</em> <br /> <code class="ocaml">fare@alacris.io</code></p><div align="left"><small>â€¯</small></div><p>LambdaConf 2019, 2019-06-07 <br />
<a href="https://alacrisio.github.io/bdao/"><tt>https://alacrisio.github.io/bdao/</tt></a></p></section><section><h1>Introduction</h1></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>This talk</h1><div align="left">A collection of general-purpose techniques</div><div align="left">In OCaml, yet relevant to any modern typed FP</div><div align="left">Oriented towards distributed applications</div><div align="left">Used in the context of blockchain, but more general</div>â€¯<span class="fragment" data-fragment-index="1"><div align="center">... From a Lisper at heart</div></span></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>Going from Lisp to OCaml</h1>â€¯<div align="left">Experience report adopting language-enforced types</div>â€¯<div align="left">The Good: where the typesystem really helps</div><div align="left">The Bad: where the typesystem gets in the way</div><div align="left">The Ugly: how the typesystem has to improve</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>Take Home Points</h1>â€¯<div align="left">Typed FP enables robust programming at scale</div>â€¯<div align="left">You pay a steep price for it</div>â€¯<div align="left">Monotonic FP is especially fit for distributed applications</div>â€¯<div align="left">To improve Typed FP: better types &amp; metaprogramming</div></section><section><h1>Types at Work: Marshaling</h1></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Marshaling data to bytes and back</h1><div align="left">Translating data structures into byte sequences</div><div align="left">a.k.a. Serializing, Encoding, Formatting, Unparsing</div>â€¯<div align="left">Must be matched by <em>unmarshaling</em> (a.k.a. â€¦)</div>â€¯<div align="left">Necessary to communicate and/or persist data</div>â€¯<div align="left">Great sink of labor (old IBM study: 30% of code)</div><div align="left">Great fount of bugs &amp; vulnerabilitiesâ€¦</div></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Level 1: Processing Byte Buffers</h1><div align="left"><code class="ocaml">process_request: Bytes.t -&gt; Bytes.t</code></div>â€¯<div align="left">Read: <code class="ocaml">let b = inbuf.(n) in if b == 1 then â€¦</code></div><div align="left">Write: <code class="ocaml">match val with C x -&gt; outbuf.(n) = (f x) â€¦ </code></div>â€¯<div align="left">OCaml types don't help at all (but bounds checks do)</div><div align="left">Might as well use C - it'd be faster</div><!--OK, in FORTH. Let's at least pick a functional language, not a dysfunctional language-->â€¯<div align="left">&quot;Shotgun parser&quot;: parser peppered into processor</div><div align="left">Very fast... like grapeshot fired at your foot</div>â€¯<span class="fragment" data-fragment-index="1"><div align="center">LangSec: DON'T DO IT</div></span><!--Language Theoretic Security -- see talk by Meredith Patterson in a previous LambdaConf--></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Level 2: Processing JSON (or XML, etc.)</h1><div align="left"><code class="ocaml">process_request: json -&gt; json</code></div>â€¯â€¯<div align="left">Dynamic type safety</div><div align="left">Might as well use Lisp - macros would help a lot</div><div align="left">Still &quot;Shotgunning&quot; structural integrity checks</div><div align="left">Somewhat slow, only so safe, painful in OCaml</div>â€¯<span class="fragment" data-fragment-index="1"><div align="left">Missing the whole point of OCaml</div></span></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Level 3: Marshaling messages by hand</h1><div align="left"><code class="ocaml">process_request: request -&gt; response</code></div><div align="left"><code class="ocaml">type 'a marshaler = Buffer.t -&gt; 'a -&gt; unit</code></div><div align="left"><code class="ocaml">type 'a unmarshaler = int -&gt; Bytes.t -&gt; 'a*int</code></div>â€¯<div align="left">Lots of bug-prone drudgery writing (un)parsers</div></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Level 4: Marshaling combinators</h1><div align="left"><code class="ocaml">type 'a marshaling = <br />
Â Â  { marshal: 'a marshaler; unmarshal: 'a unmarshaler }
val marshaling2 : ('x -&gt; 'a*'b) -&gt; ('a -&gt; 'b -&gt; 'x) -&gt; <br />
Â  'a marshaling -&gt; 'b marshaling -&gt; 'x marshaling</code></div>â€¯<div align="left">Much less bug-prone and drudgery, but still too much</div></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Level 5: Derive marshaling from type</h1><div align="left">OCaml PPX: metaprogramming</div><div align="left">Compared to Lisp macros, quite heavy to use and not composable</div></section><section><p align="right" valign="top"><font size="4"><b>Types at Work: Marshaling</b></font></p><h1>Level 6: Use GADT</h1><div align="left"><code class="ocaml">process_request: 'a request -&gt; 'a response</code></div>â€¯<div align="left">Problem: even tougher to use with PPX</div><!--Many popular PPX libraries we use don't work well with GADT--><div align="left">Still a TBD item for us</div></section><section><h1>Types: Benefits and Costs</h1></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Why use OCaml rather than Lisp?</h1><div align="left">Cryptocurrency applications: can't afford a single bug.</div>â€¯<div align="left">Types can find bugs <em>before</em> deployment.</div>â€¯<div align="left">Types critical to communicate design constraints to coworkers.</div>â€¯<div align="left">Parametricity enables robust abstraction over many levels of semantics</div>â€¯<div align="left">Putting types first makes you ask important questions.</div></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Downsides of OCaml versus Lisp?</h1><div align="left">The typesystem rejects the Lisp-easy solution.</div>â€¯<div align="left">The syntax is a hindrance at many levels.</div><!--OCaml syntax is not so good.
There is often no good way to indent it.
It is not easily extensible as in Lisp.-->â€¯<div align="left">Types-first makes exploration harder.</div><!--You have to make choices early, before you know the domain well,
and change is syntactically expensive.-->â€¯<div align="left">Type errors can boggle the mind.</div><!--On the other hand, deep macro errors can also boggle the mind-->â€¯<div align="left">Dynamic evaluation is slow and awkward.</div><!--Sometimes, you do need to compute code
that depends on system configuration or user input.
Static types make that especially awkward.

On the other hand, dynamic types make more regular things slower,
so it depends what is your usage pattern.-->â€¯<div align="left">Static design patterns are repetitive and error-prone.</div><!--Patterns mean "I have run out of language." â€” Rich Hickey
A lot of syntactic repetition, that is expensive to abstract away.-->â€¯<div align="left">No macros. PPX a poor yet expensive substitute.</div><!--PPX code is heavyweight, and doesn't compose well--></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Bugs eliminated by types</h1><div align="left">Type mismatch (<code class="ocaml">int</code> for <code class="ocaml">string</code>, etc.)</div><div align="left">Improper function calls</div><div align="left">Pattern exhaustiveness</div><div align="left">Errors in untested intermediate computations</div><div align="left">Incomplete refactoring</div><div align="left">Abstraction violation (using parametrized modules)</div></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Bugs not eliminated by types</h1><div align="left">Logic bugs within a module</div><div align="left">Configuration bugs</div><!--Or bugs in your extension language--><div align="left">Integer interval errors</div><!--But fewer, and caught earlier--><div align="left">Concurrency Issues</div><!--They can be narrowed, using session types...
but only so much, and not when interacting with existing services--><div align="left">Insufficient error handling</div><!--The types might make it apparent *where* the handling should happen,
it doesn't magically insert meaningful error handlers for you.--><div align="left">â€¯â€¯â€¯â€¯â€¯â€¯â€¯â€¯â€¯â€¯</div><span class="fragment" data-fragment-index="1">C{Still, by restricting interactions,
bugs are not just fewer, but simpler <br />
â€” they fit a brainful.}</span></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Performance</h1><div align="left">Skipping runtime typechecks!</div><div align="left">Types enable many optimizations</div><!--Even more for pure functional code, but OCaml cannot afford to do them-->â€¯<div align="left">Dynamic evaluation when needed is actually slower</div><div align="left">Macros are harder, limiting user-provided optimizations</div></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Monads vs Lisp</h1><table class="noborder" id="noborder"><tr><th>Monad</th><th>Lisp</th></tr><tr><td style="text-align: left; border: none;">Error</td><td style="text-align: left; border: none;">raising conditions</td></tr><tr><td style="text-align: left; border: none;">State</td><td style="text-align: left; border: none;">assignment</td></tr><tr><td style="text-align: left; border: none;">Future</td><td style="text-align: left; border: none;">threads, futures</td></tr><tr><td style="text-align: left; border: none;">Reader</td><td style="text-align: left; border: none;">dynamic parameters</td></tr><tr><td style="text-align: left; border: none;">Control</td><td style="text-align: left; border: none;">partial continuations</td></tr><tr><td style="text-align: left; border: none;">NonDet</td><td style="text-align: left; border: none;">non-determinism</td></tr><tr><td style="text-align: left; border: none;">IO</td><td style="text-align: left; border: none;">intercepting IO primitives</td></tr><tr><td style="text-align: left; border: none;">Parsing</td><td style="text-align: left; border: none;">parser DSL</td></tr></table></section><section><p align="right" valign="top"><font size="4"><b>Types: Benefits and Costs</b></font></p><h1>Monads vs Lisp costs &amp; benefits</h1><div align="left">Monads make explicit what effects may happen where</div><!--So it's easier to reason about who does what,
but it's costlier to express computations--><div align="left">Monads force you to think about responsibility</div><!--So it's harder to fail to handle those responsibilities,
but it's costlier to express computations--><div align="left">Monads introduce plumbing that implementations may not support</div><!--Thus you may use monads in Lisp too, for partial continuations, parsing, etc.--><div align="left">Monads build higher towers of structure</div><!--Lisp keeps the structure flatter and simpler;
it introduces many opportunities for cheap punning and conciseness;
but also many opportunities for bugs, abstraction leakage, etc.--><div align="left">Monad syntax is low-level - CPS or ANF, not nested expressions</div><!--   Importantly, it's DIFFERENT from the regular syntax.
   This is a big problem in refactoring both ways as you move the effects around,
   and you must switch between syntaxes.
   A better solution is possible --- just not implemented.

Problem: switching between effect and no effect is very expensive, as it can percolate
up the call chain into the entire program, and sometimes even contaminate
data structures and everything that touches them. The problem being that
even the syntax for basic function call changes:
not only do you have to "upgrade" (or "downgrade", depending on POV) all effect types everywhere,
the sad lack of syntactic abstraction means means that when you use monads rather than pure functions,
you have to write everything in CPS or ANF rather than direct style, and vice-versa.
(if code transformation is A-OK, why not go all the way to direct style???
    do-notation is a half-assed idea, and
    those who see it as the summum of monadic notation are brain-damaged)--></section><section><h1>Monotonic Programming</h1></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Monotonicity</h1><div align="left">Purity: no state change</div><div align="left">Monotonicity: one-way state may change</div>â€¯<div align="left">Knowledge can increase, never be invalidated</div><div align="left">Least fixed-point algorithms. Git. CRDTs. Append-only logs.</div>â€¯<div align="left">Lazy is already monotonic, not pure</div><!--If everything always terminates, lazy is same as eager.
If not, there's already a side-effect that makes it not pure.--><div align="left">But no computation can live to tell the difference</div><!--... which is exactly the point of monotonic.--></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Content-Addressed Storage</h1><div align="left">Same graph-reduction model as all common functional languages</div><div align="left">Pointer: content digest, not memory addresses</div>â€¯<div align="left">Assume standard cryptographic assumptions</div><div align="left">DAG-only, no cycles</div><!--Usual tricks to encode cyclical structures apply-->â€¯<div align="left"><code class="ocaml">let db_value_of_digest unmarshal_string digest =
  digest |&gt; db_key_of_digest |&gt; Db.get |&gt; Option.get |&gt; unmarshal_string</code></div></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Abstracting Content-Addressing</h1><div align="left">General wrapper interface</div><code class="ocaml">module type WrapS = sig
Â Â type t
Â Â type value
Â Â val get: t -&gt; value
Â Â val make: value -&gt; t
end</code>â€¯<div align="left">Identity vs lazy-loading from content-addressed store</div>â€¯<div align="left">Higher-Order modules to abstract over persistence of not</div></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Is it an effect?</h1><div align="left">Escape to impure behavior</div><div align="left">Pure at one level, impure at another</div><div align="left">Same for logging</div><span class="fragment" data-fragment-index="1"><div align="left">Same for lazy evaluation</div></span><span class="fragment" data-fragment-index="1"><div align="left">Same for allocation!</div></span><span class="fragment" data-fragment-index="1"><div align="center">Same for everything!!!</div></span><!--See my previous talk on first-class implementations--></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Lenses</h1><div align="left">Usual pure functional read/write accessors.</div>â€¯<code class="ocaml">type ('a, 'b) t = { get : 'a -&gt; 'b; set : 'b -&gt; 'a -&gt; 'a }</code><!--There are more elaborate categorical representations,
but that's not my point here-->â€¯<div align="left">Do all modifications in pure style, <hr />
then monotonically update the state variables</div></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Zipping through a tree</h1><code class="ocaml">type (+'a) path <br />
val path_map: ('a -&gt; 'b) -&gt; 'a path -&gt; 'b path <br />
type zipper = t * t path <br />
val zip : t -&gt; zipper <br />
val unzip : zipper -&gt; t <br />
val find_path : key -&gt; t -&gt; zipper</code></section><section><p align="right" valign="top"><font size="4"><b>Monotonic Programming</b></font></p><h1>Merklization</h1><div align="left">Merklize: make computations verifiable</div><div align="left">Zippers-as-data trivialize merklization:</div><code class="ocaml">let merkle_proof key mt =
Â Â match map_fst Wrap.get (find_path key mt) with
Â Â Â Â | Leaf {value}, up -&gt;
Â Â Â Â Â Â Â Â Some { key ; trie = node_digest mt
Â Â Â Â Â Â Â Â Â Â Â Â Â ; leaf = merklize_leaf value
Â Â Â Â Â Â Â Â Â Â Â Â Â ; steps = (path_map node_digest up).steps }
Â Â Â Â | _ -&gt; None</code></section><section><h1>Future Improvements to Typesystems</h1></section><section><p align="right" valign="top"><font size="4"><b>Future Improvements to Typesystems</b></font></p>Objects done right<div align="left">OCaml modules don't support late binding or fix-pointing</div><div align="left">OCaml objects are limited in many ways</div>â€¯<div align="left">Nix: prototype inheritance in 6 short library functions</div><div align="left">You can't type prototypes in OCaml (or Haskell, etc.)</div><div align="center">You need appendable row types</div>â€¯<div align="left">Multimethods? Method combinations? Meta-object protocol?</div></section><section><p align="right" valign="top"><font size="4"><b>Future Improvements to Typesystems</b></font></p>Schema Upgrade<div align="left">A real program works on persistent data</div>â€¯<div align="left">Modern programming languages only create toys</div>â€¯<div align="left">Non-toys use databases. But they have horrible PLs!</div>â€¯<div align="left">Lisp supports schema upgrade. Can static types do it?</div></section><section><p align="right" valign="top"><font size="4"><b>Future Improvements to Typesystems</b></font></p>Better Effect Typing and Syntax<div align="left">Monads are semantically awkward</div>â€¯<div align="left">Monad notation is syntactically horrible</div>â€¯<div align="left">NB: Jane Street is funding effect typing for OCaml</div>â€¯<div align="left">One man's pure bliss is another man's effects</div></section><section><p align="right" valign="top"><font size="4"><b>Future Improvements to Typesystems</b></font></p>Compile-time Reflectionâ€¯<div align="left">Refinement logic --- relating layers of abstraction, correctly</div>â€¯<div align="left">Make explicit multiple levels of computations</div>â€¯<div align="left">Extending the type with domain-specific logic fragments: <br />
linear (URALâ€¦), modal (temporal, epistemicâ€¦), finitary, etc.</div>â€¯<div align="left">A composable alternative to PPX... macros?</div></section><section><p align="right" valign="top"><font size="4"><b>Future Improvements to Typesystems</b></font></p>Reconciling Types and Macros<div align="left">Anything information used by a macro is a type: <br />
compile-time information deduced from the source.</div>â€¯<div align="left">Any type-level programming is a macro: <br />
compile-time transformation of source code.</div>â€¯<div align="center">WHY CAN'T I HAVE BOTH, COMPOSABLY?</div>â€¯<span class="fragment" data-fragment-index="1"><div align="center">&quot;Type Systems as Macros&quot; by Chang, Knauth, Greenman</div></span></section><section><p align="right" valign="top"><font size="4"><b>Future Improvements to Typesystems</b></font></p>Runtime Reflection<div align="left">Providing safety and performance to dynamic code, too</div>â€¯<div align="left">Virtualization: Separate fore-program from controlling back-program</div>â€¯<div align="left">Instrumentation: Natural transformations on implementations</div>â€¯<div align="left">Code Migration.</div>â€¯<div align="left">Native GC, integrated with monotonic database cacheâ€¦</div></section><section><h1>Conclusion</h1></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Take Home Points (redux)</h1>â€¯<div align="left">Typed FP enables robust programming at scale</div>â€¯<div align="left">You pay a steep price for it</div>â€¯<div align="left">Monotonic FP is especially fit for distributed applications</div>â€¯<div align="left">To improve Typed FP: better types &amp; metaprogramming</div></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>The Meta-Story</h1>â€¯<div align="left">Types can be your friends or your enemies</div>â€¯<div align="left">Life is happier when they are your friends</div>â€¯<div align="left">Life is happier when type friends are less dumb</div>â€¯<div align="left">OCaml type friends are decent, could be even better</div></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Thanks</h1>â€¯<div align="left">Our startup: Â  <em>Alacris</em> Â <a href="https://alacris.io/"><tt>https://alacris.io/</tt></a></div>â€¯<div align="left">WE ARE EITHER HIRING OR BANKRUPT! Â  (No constructive proof yet.)</div>â€¯<div align="left">DO YOU HAVE EXTRA MILLIONS? Â  Seed capital, Research grantsâ€¦</div>â€¯<div align="left">SHOW ME THE CODE! Â  <a href="https://github.com/AlacrisIO/legicash-facts"><tt>https://github.com/AlacrisIO/legicash-facts</tt></a></div></section></div></div>
<script src="resources/reveal/lib/js/head.min.js"></script>
<script src="resources/reveal/js/reveal.min.js"></script>
<script>
//<![CDATA[
Reveal.initialize({
  dependencies: [
    {src: "resources/reveal/plugin/highlight/highlight.js",
     async: true, callback: () => hljs.initHighlightingOnLoad()}],
  controls: false})
//]]>
</script></body></html>