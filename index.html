#<special>
<html><head><meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<link rel="stylesheet" href="resources/my.css" />
<link rel="stylesheet" href="resources/reveal/css/reveal.css" />
<link rel="stylesheet" href="resources/reveal/css/theme/black.css" />
<link rel="stylesheet" href="resources/reveal/lib/css/zenburn.css" />
<link rel="stylesheet" href="resources/my.css" /></head>
<body style="background-repeat: no-repeat; background-size: 15%; background-origin: padding-box; background-position: bottom 1% right 1%; background-image: url('resources/pic/alacris_small_logo.png'); "><div class="reveal"><div class="slides"><section><table><tr><td width="10%"></td><td width="32%"><img src="resources/pic/alacris_logo.png" style="border: 0; vertical-align: top; background-color: transparent" /></td><td width="15%"></td><td><font fgcolor="#ff0000" size="7"><b>𝔹  uilding <br />
𝔻  istributed <br />
𝔸  pplications in <br />
𝕆  Caml</b></font></td></tr></table> <div align="left"><small> </small></div><div align="center" style="font-size: 1.2em; font-weight: bold;">Making types your friends, not your enemies</div> <p>François-René Rideau,  <em>Alacris</em> <br /> <code class="ocaml">fare@alacris.io</code></p><div align="left"><small> </small></div><p>LambdaConf 2019, 2019-06-07 <br />
<a href="https://alacrisio.github.io/bdao/"><tt>https://alacrisio.github.io/bdao/</tt></a></p></section><section><h1>Introduction</h1></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>This talk</h1><div align="left">A collection of general-purpose techniques</div><div align="left">In OCaml, yet relevant to any modern typed FP</div><div align="left">Oriented towards distributed applications</div><div align="left">Used in the context of blockchain, but more general</div> <span class="fragment" data-fragment-index="1"><div align="center">... From a Lisper at heart</div></span></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>Going from Lisp to OCaml</h1> <div align="left">Experience report adopting language-enforced types</div> <div align="left">The Good: where the typesystem really helps</div><div align="left">The Bad: where the typesystem gets in the way</div><div align="left">The Ugly: how the typesystem has to improve</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>Why use OCaml rather than Lisp?</h1><div align="left">Cryptocurrency applications: can't afford a single bug.</div> <div align="left">Types can find bugs <em>before</em> deployment.</div><div align="left">Types critical to communicate design constraints to coworkers.</div><div align="left">Modules enable robust abstraction over many levels of semantics</div><div align="left">Having to put types first makes you ask important questions.</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>Downsides of OCaml versus Lisp?</h1><div align="left">The typesystem rejects the Lisp-easy solution.</div><div align="left">The syntax is a hindrance at many levels.</div><div align="left">Types-first makes exploration harder.</div><div align="left">Type errors can boggle the mind.</div><div align="left">Dynamic evaluation is slow and awkward.</div><div align="left">Static patterns are repetitive and error-prone.</div><div align="left">No macros. PPX a poor yet expensive substitute.</div></section><section><p align="right" valign="top"><font size="4"><b>Introduction</b></font></p><h1>Take Home Points</h1> <div align="left">Typed FP enables robust programming at scale</div> <div align="left">You pay a steep price for it</div> <div align="left">Pure FP is especially fit for distributed applications</div> <div align="left">To improve Typed FP: better types &amp; metaprogramming</div></section><section><h1>Bugs eliminated by types</h1><div align="left">Type mismatch (<tt>int</tt> for <tt>string</tt>, etc.)</div><div align="left">Improper function calls</div><div align="left">Pattern exhaustiveness</div><div align="left">Errors in untested intermediate computations</div><div align="left">Incomplete refactoring</div><div align="left">Abstraction violation (using parametrized modules)</div></section><section><h1>Bugs not eliminated by types</h1><div align="left">Logic bugs within a module</div><div align="left">Configuration bugs</div><!--Or bugs in your extension language--><div align="left">Integer interval errors</div><!--But fewer, and caught earlier--><div align="left">Concurrency Issues</div><!--They can be narrowed, using session types...
but only so much, and not when interacting with existing services--><div align="left"></div><!----><div align="left">          </div><div align="center">Still, by restricting interactions,
bugs are not just fewer, but simpler <br />
— they fit a brainful.</div></section><section><h1>Performance</h1><div align="left">Skipping runtime typechecks!</div><div align="left">Types enable many optimizations</div><!--Even more for pure functional code, but OCaml cannot afford to do them--> <div align="left">Dynamic evaluation when needed is actually slower</div><div align="left">Macros are harder, limiting user-provided optimizations</div></section><section><h1>Monads vs Lisp</h1><table class="noborder" id="noborder"><tr><th>Monad</th><th>Lisp</th></tr><tr><td style="text-align: left; border: none;">Error</td><td style="text-align: left; border: none;">raising conditions</td></tr><tr><td style="text-align: left; border: none;">State</td><td style="text-align: left; border: none;">assignment</td></tr><tr><td style="text-align: left; border: none;">Future</td><td style="text-align: left; border: none;">threads, futures</td></tr><tr><td style="text-align: left; border: none;">Reader</td><td style="text-align: left; border: none;">dynamic parameters</td></tr><tr><td style="text-align: left; border: none;">Control</td><td style="text-align: left; border: none;">partial continuations</td></tr><tr><td style="text-align: left; border: none;">NonDet</td><td style="text-align: left; border: none;">non-determinism</td></tr><tr><td style="text-align: left; border: none;">IO</td><td style="text-align: left; border: none;">intercepting IO primitives</td></tr><tr><td style="text-align: left; border: none;">Parsing</td><td style="text-align: left; border: none;">parser DSL</td></tr></table></section><section><h1>Monads vs Lisp costs &amp; benefits</h1><div align="left">Monads make explicit what effects may happen where</div><!--So it's easier to reason about who does what,
but it's costlier to express computations--><div align="left">Monads force you to think about responsibility</div><!--So it's harder to fail to handle those responsibilities,
but it's costlier to express computations--><div align="left">Monads introduce plumbing that implementations may not support</div><!--Thus you may use monads in Lisp too, for partial continuations, parsing, etc.--><div align="left">Monads build higher towers of structure</div><!--Lisp keeps the structure flatter and simpler;
it introduces many opportunities for cheap punning and conciseness;
but also many opportunities for bugs, abstraction leakage, etc.--><div align="left">Monad syntax is low-level - CPS or ANF, not nested expressions</div><!--   Importantly, it's DIFFERENT from the regular syntax.
   This is a big problem in refactoring both ways as you move the effects around,
   and you must switch between syntaxes.
   A better solution is possible --- just not implemented.

Problem: switching between effect and no effect is very expensive, as it can percolate
up the call chain into the entire program, and sometimes even contaminate
data structures and everything that touches them. The problem being that
even the syntax for basic function call changes:
not only do you have to "upgrade" (or "downgrade", depending on POV) all effect types everywhere,
the sad lack of syntactic abstraction means means that when you use monads rather than pure functions,
you have to write everything in CPS or ANF rather than direct style, and vice-versa.
(if code transformation is A-OK, why not go all the way to direct style???
    do-notation is a half-assed idea, and
    those who see it as the summum of monadic notation are brain-damaged)--></section><section><h1>Marshaling</h1></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Marshaling data to bytes and back</h1><div align="left">Translating data structures into byte sequences</div><div align="left">a.k.a. Serializing, Encoding, Formatting, Unparsing</div> <div align="left">Must be matched by <em>unmarshaling</em> (a.k.a. etc.)</div> <div align="left">Necessary to communicate and/or persist data</div> <div align="left">Great sink of labor (old IBM study: 30% of code)</div><div align="left">Great fount of bugs &amp; vulnerabilities…</div></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Level 1: Processing Byte Buffers</h1><div align="left"><code class="ocaml">server: input_stream -&gt; output_stream -&gt; unit</code></div> <div align="left">Read: <code class="ocaml">let b = inbuf.(n) in if b == 1 then …</code></div><div align="left">Write: <code class="ocaml">match val with C x -&gt; outbuf.(n) = (f x) … </code></div> <div align="left">OCaml types don't help at all (but bounds checks do)</div><div align="left">Might as well use C - it'd be faster</div><!--OK, in FORTH. Let's at least pick a functional language, not a dysfunctional language--> <div align="left">&quot;Shotgun parser&quot;: parser peppered into processor</div><div align="left">Very fast... like grapeshot fired at your foot</div> <span class="fragment" data-fragment-index="1"><div align="center">LangSec: DON'T DO IT</div></span><!--Language Theoretic Security -- see talk by Meredith Patterson in a previous LambdaConf--></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Level 2: Processing JSON (or XML, etc.)</h1><div align="left"><code class="ocaml">server: json -&gt; json</code></div>  <div align="left">Dynamic type safety</div><div align="left">Might as well use Lisp - macros would help a lot</div><div align="left">Still &quot;Shotgunning&quot; structural integrity checks</div><div align="left">Somewhat slow, only so safe, painful in OCaml</div> <span class="fragment" data-fragment-index="1"><div align="left">Missing the whole point of OCaml</div></span></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Level 3: Marshaling messages by hand</h1><div align="left"><code class="ocaml">server: request -&gt; response</code></div><div align="left"><code class="ocaml">type 'a marshaler = Buffer.t -&gt; 'a -&gt; unit</code></div><div align="left"><code class="ocaml">type 'a unmarshaler = int -&gt; Bytes.t -&gt; 'a*int</code></div> <div align="left">Lots of bug-prone drudgery writing (un)parsers</div></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Level 4: Marshaling combinators</h1><div align="left"><code class="ocaml">type 'a marshaling = <br />   { marshal: 'a marshaler; unmarshal: 'a unmarshaler }</code></div><div align="left"><code class="ocaml">val marshaling2 : ('x -&gt; 'a*'b) -&gt; ('a -&gt; 'b -&gt; 'x) -&gt; <br />  
'a marshaling -&gt; 'b marshaling -&gt; 'x marshaling</code></div> <div align="left">Much less bug-prone and drudgery, but still too much</div></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Level 5: Derive marshaling from type</h1><div align="left">OCaml PPX: metaprogramming</div><div align="left">Compared to Lisp macros, quite heavy to use and not composable</div></section><section><p align="right" valign="top"><font size="4"><b>Marshaling</b></font></p><h1>Level 6: Use GADT</h1><div align="left"><code class="ocaml">server: 'a request -&gt; 'a response</code></div> <div align="left">Problem: even tougher to use with PPX</div><div align="left">Still a TBD item for us</div></section><section><h1>Content-Addressed Storage</h1></section><section><p align="right" valign="top"><font size="4"><b>Content-Addressed Storage</b></font></p><h1>Content-Addressing</h1></section><section><p align="right" valign="top"><font size="4"><b>Content-Addressed Storage</b></font></p><h1>Abstracting Content-Addressing</h1><div align="left">wrap values in lazy-loading</div><div align="left">Higher-Order modules to abstract over persistence of not</div><span class="fragment" data-fragment-index="1"><div align="left">Break the pure interface???</div></span></section><section><p align="right" valign="top"><font size="4"><b>Content-Addressed Storage</b></font></p><h1>Is it an effect?</h1><div align="left">Escape to impure behavior</div><div align="left">Pure at one level, impure at another</div><div align="left">Same for logging</div><span class="fragment" data-fragment-index="1"><div align="left">Same for lazy evaluation</div></span><span class="fragment" data-fragment-index="1"><div align="left">Same for allocation!</div></span><span class="fragment" data-fragment-index="1"><div align="center">Same for everything!</div></span></section><section><h1>Optics</h1></section><section><p align="right" valign="top"><font size="4"><b>Optics</b></font></p><h1>Lenses</h1></section><section><p align="right" valign="top"><font size="4"><b>Optics</b></font></p><h1>Zippers</h1><div align="left">Lens as data rather than function</div></section><section><p align="right" valign="top"><font size="4"><b>Optics</b></font></p><h1>Zipping through a tree</h1><tt>type (+'a) step <br />
type (+'a) path <br />
val step_map: ('a -&gt; 'b) -&gt; 'a step -&gt; 'b step
val path_map: ('a -&gt; 'b) -&gt; 'a path -&gt; 'b path
type zipper = t * t path
val zip : t -&gt; zipper
val unzip : zipper -&gt; t
val next: zipper -&gt; zipper list
val find_path : key -&gt; t -&gt; zipper</tt></section><section><p align="right" valign="top"><font size="4"><b>Optics</b></font></p><h1>Merklization</h1><div align="left">Merklize: make computations verifiable</div><div align="left">Zippers trivialize merklization:</div><code class="ocaml">let get (key: key) (mt: mtrie) : t option =
  match map_fst Wrap.get (find_path key mt) with
    | Leaf {value}, up -&gt;
        Some { key ; trie = dv_digest mt
             ; leaf = SynthMerkle.leaf value
             ; steps = (path_digest up).steps }
    | _ -&gt; None</code></section><section><h1>Conclusion</h1></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Take Home Points (redux)</h1> <div align="left">Typed FP enables robust programming at scale</div> <div align="left">You pay a steep price for it</div> <div align="left">Pure FP is especially fit for distributed applications</div> <div align="left">To improve Typed FP: better types &amp; metaprogramming</div></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>The Meta-Story</h1> <div align="left">Types can be your friends or your enemies</div> <div align="left">Life is happier when they are your friends</div> <div align="left">Life is happier when type friends are less dumb</div> <div align="left">OCaml type friends are decent, could be even better</div></section><section><p align="right" valign="top"><font size="4"><b>Conclusion</b></font></p><h1>Thanks</h1> <div align="left">Our startup:   <em>Alacris</em>  <a href="https://alacris.io/"><tt>https://alacris.io/</tt></a></div> <div align="left">WE ARE EITHER HIRING OR BANKRUPT!   (No constructive proof yet.)</div> <div align="left">DO YOU HAVE EXTRA MILLIONS?   Seed capital, Research grants…</div> <div align="left">SHOW ME THE CODE!   <a href="https://github.com/AlacrisIO/legicash-facts"><tt>https://github.com/AlacrisIO/legicash-facts</tt></a></div></section></div></div>
<script src="resources/reveal/lib/js/head.min.js"></script>
<script src="resources/reveal/js/reveal.min.js"></script>
<script>
//<![CDATA[
Reveal.initialize({
  dependencies: [
    {src: "resources/reveal/plugin/highlight/highlight.js",
     async: true, callback: () => hljs.initHighlightingOnLoad()}],
  controls: false})
//]]>
</script></body></html>